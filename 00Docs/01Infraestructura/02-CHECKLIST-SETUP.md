# Checklist de Setup - Plataforma Gestión Comercial
## Guía Paso a Paso

---

## Estado Actual

- [x] Repositorio creado
- [x] Frontend inicializado (Vue 3 + Vite)
- [x] Backend inicializado (Spring Boot 3.3)
- [x] Java 21 instalado
- [x] Node.js instalado
- [ ] **Conectar backend a Oracle** ← SIGUIENTE PASO
- [ ] Ejecutar backend correctamente
- [ ] Dockerfiles
- [ ] Docker Compose
- [ ] Deploy

---

## PASO 1: Configurar conexión a Oracle (backend)

### 1.1 Crear archivo `.env` en la raíz del backend

```bash
cd /D/Proyectos/gestion-comercial/backend
```

Crear archivo `.env` con este contenido:

```bash
DB_URL=jdbc:oracle:thin:@//arqsmallpldbs01-public-phx.infra.arqbs.com:1621/CDBSMALL_ARQSMALLPLDBS01_COMMSRV.paas.oracle.com
DB_USERNAME=ARQGCDEV
DB_PASSWORD=xGMa_ME9iuH0B_pj_N9j
JWT_SECRET=arquitecsoft_gestion_comercial_jwt_secret_2026
```

### 1.2 Configurar application.yml

Editar `backend/src/main/resources/application.yml`:

```yaml
spring:
  application:
    name: gestion-backend

  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: oracle.jdbc.OracleDriver
    hikari:
      maximum-pool-size: 5

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: true

  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true

server:
  port: 8080

app:
  jwt:
    secret: ${JWT_SECRET}
    expiration: 28800000

springdoc:
  api-docs:
    path: /api/docs
  swagger-ui:
    path: /api/swagger-ui.html
```

### 1.3 Verificar que pom.xml tenga el driver Oracle

Abrir `backend/pom.xml` y verificar que exista:

```xml
<dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc11</artifactId>
    <scope>runtime</scope>
</dependency>
```

### 1.4 Crear la primera migración Flyway

Crear archivo `backend/src/main/resources/db/migration/V1__initial_schema.sql`:

```sql
CREATE TABLE GC_USUARIOS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    USERNAME VARCHAR2(50) NOT NULL UNIQUE,
    EMAIL VARCHAR2(100) NOT NULL UNIQUE,
    PASSWORD_HASH VARCHAR2(255) NOT NULL,
    NOMBRE VARCHAR2(100) NOT NULL,
    ACTIVO NUMBER(1) DEFAULT 1,
    FECHA_CREACION TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IDX_USUARIOS_USERNAME ON GC_USUARIOS(USERNAME);
CREATE INDEX IDX_USUARIOS_EMAIL ON GC_USUARIOS(EMAIL);
```

### 1.5 Crear HealthController para probar

Crear archivo `backend/src/main/java/com/arquitecsoft/gestion/config/HealthController.java`:

```java
package com.arquitecsoft.gestion.config;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.Map;

@RestController
public class HealthController {

    @GetMapping("/health")
    public Map<String, String> health() {
        return Map.of(
            "status", "UP",
            "service", "gestion-backend"
        );
    }
}
```

### 1.6 Desactivar Spring Security temporalmente

Crear archivo `backend/src/main/java/com/arquitecsoft/gestion/config/SecurityConfig.java`:

```java
package com.arquitecsoft.gestion.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .anyRequest().permitAll()
            );
        return http.build();
    }
}
```

### 1.7 Ejecutar el backend

```bash
cd /D/Proyectos/gestion-comercial/backend

# En Windows, cargar variables del .env primero
# Opción A: Desde Git Bash
export $(cat .env | xargs)
./mvnw spring-boot:run

# Opción B: Desde PowerShell
# Copiar las variables directamente en application.yml temporalmente
```

### 1.8 Verificar

Abrir en el navegador:
- http://localhost:8080/health → debe mostrar `{"status":"UP","service":"gestion-backend"}`
- http://localhost:8080/api/swagger-ui.html → debe mostrar Swagger UI

- [ ] Backend conecta a Oracle
- [ ] Health endpoint responde
- [ ] Flyway creó la tabla GC_USUARIOS

---

## PASO 2: Verificar Frontend (5 min)

```bash
cd /D/Proyectos/gestion-comercial/frontend
npm run dev
```

Abrir http://localhost:5173

- [ ] Frontend corre

---

## PASO 3: Crear Dockerfiles (10 min)

### 3.1 Frontend - Dockerfile

Crear `frontend/Dockerfile`:

```dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 3.2 Frontend - nginx.conf

Crear `frontend/nginx.conf`:

```nginx
server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    gzip on;
    gzip_types text/plain text/css application/json application/javascript;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api/ {
        proxy_pass http://backend:8080/api/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    location /health {
        return 200 '{"status":"UP"}';
        add_header Content-Type application/json;
    }
}
```

### 3.3 Backend - Dockerfile

Crear `backend/Dockerfile`:

```dockerfile
FROM eclipse-temurin:21-jdk-alpine AS builder
WORKDIR /app
COPY mvnw pom.xml ./
COPY .mvn .mvn
RUN ./mvnw dependency:go-offline -B
COPY src src
RUN ./mvnw package -DskipTests

FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

- [ ] Dockerfiles creados

---

## PASO 4: Docker Compose (5 min)

### 4.1 Crear `docker-compose.yml` en la raíz

```yaml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "8080:8080"
    environment:
      - DB_URL=${DB_URL}
      - DB_USERNAME=${DB_USERNAME}
      - DB_PASSWORD=${DB_PASSWORD}
      - JWT_SECRET=${JWT_SECRET}
```

### 4.2 Crear `.env` en la raíz del proyecto

```bash
DB_URL=jdbc:oracle:thin:@//arqsmallpldbs01-public-phx.infra.arqbs.com:1621/CDBSMALL_ARQSMALLPLDBS01_COMMSRV.paas.oracle.com
DB_USERNAME=ARQGCDEV
DB_PASSWORD=xGMa_ME9iuH0B_pj_N9j
JWT_SECRET=arquitecsoft_gestion_comercial_jwt_secret_2026
```

### 4.3 Probar

```bash
cd /D/Proyectos/gestion-comercial
docker-compose up --build
```

- [ ] Frontend en http://localhost
- [ ] Backend en http://localhost:8080/health

---

## PASO 5: Deploy a VM en OCI (cuando estés listo)

Esto se hace después de tener la aplicación funcionando localmente con Docker Compose. Los pasos serán:

1. Crear VM en OCI
2. Instalar Docker en la VM
3. Copiar archivos con rsync
4. Ejecutar docker-compose en la VM

---

## Resumen de Orden

```
PASO 1: Conectar backend a Oracle     ← AHORA
PASO 2: Verificar frontend
PASO 3: Crear Dockerfiles
PASO 4: Docker Compose local
PASO 5: Deploy a OCI (después)
```
